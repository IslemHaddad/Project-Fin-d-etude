# -*- coding: utf-8 -*-
"""SuperModels.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17LTQvbQqq0cpmWRUlrA0uXh30QFqv-7C
"""

from google.colab import drive
drive.mount('/content/gdrive')

Model_path = 'T1CFLAIR'

    
def dice_coef_edema(y_true, y_pred, smooth=1):
  import tensorflow as tf

  y_true = tf.reshape(y_true[:][:][:][1],(-1,64,64,1))
  y_pred = tf.reshape(y_pred[:][:][:][1],(-1,64,64,1))
  from keras import backend as K
  intersection = K.sum(y_true * y_pred, axis=[1,2,3])
  union = K.sum(y_true, axis=[1,2,3]) + K.sum(y_pred, axis=[1,2,3])
  dice = (2. * intersection )/(union )
  return dice
 
def jaccard_distance_edema(y_true, y_pred, smooth=1):
    import tensorflow as tf

    y_true = tf.reshape(y_true[:][:][:][1],(-1,64,64,1))
    y_pred = tf.reshape(y_pred[:][:][:][1],(-1,64,64,1))

    from keras import backend as K
    intersection = K.sum(y_true * y_pred, axis=[1,2,3])
    sum_ = K.sum(y_true + y_pred, axis=[1,2,3])
    jac = (intersection ) / (sum_ - intersection)
    return jac
 
def dice_coef_tumor(y_true, y_pred, smooth=1):
  import tensorflow as tf

  y_true = tf.reshape(y_true[:][:][:][2],(-1,64,64,1))
  y_pred = tf.reshape(y_pred[:][:][:][2],(-1,64,64,1))
  from keras import backend as K
  intersection = K.sum(y_true * y_pred, axis=[1,2,3])
  union = K.sum(y_true, axis=[1,2,3]) + K.sum(y_pred, axis=[1,2,3])
  dice = (2. * intersection)/(union)
  return dice
 
def jaccard_distance_tumor(y_true, y_pred, smooth=1):
    import tensorflow as tf

    y_true = tf.reshape(y_true[:][:][:][2],(-1,64,64,1))
    y_pred = tf.reshape(y_pred[:][:][:][2],(-1,64,64,1))
    from keras import backend as K
    intersection = K.sum(y_true * y_pred, axis=[1,2,3])
    sum_ = K.sum(y_true + y_pred, axis=[1,2,3])
    jac = (intersection) / (sum_ - intersection)
    return jac


class CreateSubImages():
  def __init__(self,Brains=[],Type=[],shape=()):
 
    self.Brains = Brains
    self.Types = Type
    self.shape = shape
    self.Model_Net = None
    self.Useful_Images = dict()
    self.Images = dict()
    self.Truths = dict()
    self.SubImages = dict()
    self.SubTruths = dict()
    self.Data = []
    self.Masks = []
 
 
  def Get_Slices_Images(self,Image,Type):
    import glob
    paths_for_images_and_truths = dict()
 
    for i in range(200):
      slice = f'{Image}_{Type}_slice_{str(i+1).zfill(2)}'
      truth = f'{Image}_truth_slice_{str(i+1).zfill(2)}'
      image_list = glob.glob(f'./gdrive/MyDrive/Images/{Image}/{slice}.jpg')
 
      if len(image_list) >= 1:
        image = image_list[0]
 
      mask_list = glob.glob(f'./gdrive/MyDrive/Images/Truth/{truth}.jpg')
      if len(mask_list) >= 1:
        mask = mask_list[0]
        if image != None and mask != None:
          paths_for_images_and_truths[slice] = (image,mask)
    return paths_for_images_and_truths
 
 
 
  def Turn_Image_To_Multiple_Small_Images_With_Truth(self,image,name):
    data = dict()
    subimages = []
    list_of_names = []
    for i in range(self.shape[0]):
      for j in range(self.shape[1]):
        data[f'{name}_pos_{i}_{j}'] = image[i:self.shape[0],j:self.shape[1]]
    
    return data    
 
  def Write_Json(self,JsonFileName,Data,full_or_sub,image_or_mask,Type):
    import pickle
    import os
    if image_or_mask == 'image':
      if full_or_sub == 'sub':
        f = open(f'./gdrive/MyDrive/{JsonFileName[:12]}_{Type}_image_split.pkl','a')
        f.close()
        f = open(f'./gdrive/MyDrive/{JsonFileName[:12]}_{Type}_image_split.pkl','wb')
        pickle.dump(Data,f)
        f.close()
      if full_or_sub == 'full':
        f = open(f'./gdrive/MyDrive/{JsonFileName[:12]}_{Type}_image.pkl','a')
        f.close()
        f = open(f'./gdrive/MyDrive/{JsonFileName[:12]}_{Type}_image.pkl','wb')
        pickle.dump(Data,f)
        f.close()
    elif image_or_mask == 'mask':
      if full_or_sub == 'sub':
        if os.path.exists(f'./gdrive/MyDrive/{JsonFileName[:12]}_mask_split.pkl') == False:
          f = open(f'./gdrive/MyDrive/{JsonFileName[:12]}_mask_split.pkl','a')
          f.close()
        f = open(f'./gdrive/MyDrive/{JsonFileName[:12]}_mask_split.pkl','wb')
        pickle.dump(Data,f)
        f.close()
      if full_or_sub == 'full':
        if os.path.exists(f'./gdrive/MyDrive/{JsonFileName[:12]}_{Type}_mask.pkl'):
          f = open(f'./gdrive/MyDrive/{JsonFileName[:12]}_{Type}_mask.pkl','a')
          f.close()
        f = open(f'./gdrive/MyDrive/{JsonFileName[:12]}_{Type}_mask.pkl','wb')
        pickle.dump(Data,f)
        f.close()
    
  def Eliminate_Dark_Images(self,Image):
    import numpy as np
    if np.count_nonzero(Image):
      return True
    else:
      return False
 
  def MakeEverything(self,key,Type):
    '''self.Write_Json(key,self.Data,'sub','image',type)
    self.Write_Json(key,self.Masks,'sub','mask',type)'''
 
    self.Write_Json(key,self.Data,'full','image',Type)
    self.Write_Json(key,self.Masks,'full','mask',Type)
    self.Data = []
    self.Masks = []
 
  def Load_Data(self,Full_Or_Sub,Brains,Type):
    import glob
    import pickle
    import numpy as np
    pathImage = ''
    pathMask = ''
    self.Data = []
    self.Masks = []
    for brain in Brains:
      if Full_Or_Sub == 'full':
        pathImage = glob.glob(f'./gdrive/MyDrive/{brain}_{Type}_image.pkl')[0]
        pathMask = glob.glob(f'./gdrive/MyDrive/{brain}_{Type}_mask.pkl')[0]
        images = open(pathImage,'rb')
        data = pickle.load(images)
        mask = open(pathMask,'rb')
        truth = pickle.load(mask)
        self.Data.append(data)
        self.Masks.append(truth)
        images.close()
        mask.close()
 
      if Full_Or_Sub == 'sub':
        pathImage = glob.glob(f'./gdrive/MyDrive/{brain}_{Type}_image.pkl')[0]
        pathMask = glob.glob(f'./gdrive/MyDrive/{brain}_{Type}_mask.pkl')[0]
        images = open(pathImage,'rb')
        data = pickle.load(images)
        mask = open(pathMask,'rb')
        truth = pickle.load(mask)
        self.Data.append(data)
        self.Masks.append(truth)
        images.close()
        mask.close()
    
    return self.Data,self.Masks
    
  def Load_Data_Multiple_Type(self,Full_Or_Sub,Brains,Type):
    import glob
    import pickle
    import numpy as np
    pathImage = ''
    pathMask = ''
    self.Data = []
    self.Masks = []
    for brain in Brains:
      for t in Type:
        if Full_Or_Sub == 'full':
          pathImage = glob.glob(f'./gdrive/MyDrive/{brain}_{t}_image.pkl')[0]
          pathMask = glob.glob(f'./gdrive/MyDrive/{brain}_{t}_mask.pkl')[0]
          images = open(pathImage,'rb')
          data = pickle.load(images)
          mask = open(pathMask,'rb')
          truth = pickle.load(mask)
          self.Data.append(data)
          self.Masks.append(truth)
          images.close()
          mask.close()
 
        if Full_Or_Sub == 'sub':
          pathImage = glob.glob(f'./gdrive/MyDrive/{brain}_{t}_image.pkl')[0]
          pathMask = glob.glob(f'./gdrive/MyDrive/{brain}_{t}_mask.pkl')[0]
          images = open(pathImage,'rb')
          data = pickle.load(images)
          mask = open(pathMask,'rb')
          truth = pickle.load(mask)
          self.Data.append(data)
          self.Masks.append(truth)
          images.close()
          mask.close()
    
    return self.Data,self.Masks
    
  def Get_Images_With_Truths(self):
    import os
    import glob
    import cv2
    import json
    cpt = 0
    for brain in self.Brains:
      print(f'{brain}')
      cpt = cpt + 1
      for image_type in self.Types:
        print(f'{image_type}')
        paths_for_images_and_truths = self.Get_Slices_Images(brain,image_type)
        for key,value in paths_for_images_and_truths.items():
            image = cv2.imread(value[0],cv2.IMREAD_GRAYSCALE)
            mask = cv2.imread(value[1],cv2.IMREAD_GRAYSCALE)
            image = image
            mask = mask
            if self.Eliminate_Dark_Images(image):
              self.Data.append(image)
              self.Masks.append(mask)
        self.MakeEverything(key,image_type)
        '''if self.Eliminate_Dark_Images(mask):
          self.SubImages[key] = self.Turn_Image_To_Multiple_Small_Images_With_Truth(image,key)
          self.SubTruths[key] = self.Turn_Image_To_Multiple_Small_Images_With_Truth(mask,key)
          self.Images[key] = image
          self.Truths[key] = mask'''
    print(cpt)
 
 
        
 
  def ShowImage(self,image,Truths):
    import matplotlib.pyplot as plt
 
    fig = plt.figure(figsize=(1, 2))
    columns = 2
    rows = 1
    for i in range(1, columns*rows +1):
        fig.add_subplot(rows, columns, i)
        plt.imshow(image)
        plt.imshow(Truths)
    plt.show()
 
  def u_net4blocks(self):
    import sys
    from tensorflow import keras
    from tensorflow.keras.layers import Concatenate,Conv2D,MaxPooling2D,Dropout,Input
    import numpy as np
    import matplotlib.pyplot as plt
    np.set_printoptions(threshold=sys.maxsize)
 
 
    '''first layer'''
    input = keras.layers.Input((64,64,1))
 
    conv2d = keras.layers.Conv2D(32,(3,3),padding='same')(input)
    dropout = keras.layers.Dropout(0.1)(conv2d)
    conv2d = keras.layers.Conv2D(32,(3,3),padding='same')(dropout)
    feature_firstDegree = keras.layers.ReLU()(conv2d)
 
 
    '''secend layer'''
    MaxPooling = keras.layers.MaxPooling2D((2,2))(feature_firstDegree)
    conv2d = keras.layers.Conv2D(64,(3,3),padding='same')(MaxPooling)
    dropout = keras.layers.Dropout(0.1)(conv2d)
    conv2d = keras.layers.Conv2D(64,(3,3),padding='same')(dropout)
    feature_secendDegree = keras.layers.ReLU()(conv2d)
 
 
 
    '''third layer'''
    MaxPooling = keras.layers.MaxPooling2D((2,2))(feature_secendDegree)
    conv2d = keras.layers.Conv2D(128,(3,3),padding='same')(MaxPooling)      
    dropout = keras.layers.Dropout(0.1)(conv2d)
    conv2d = keras.layers.Conv2D(128,(3,3),padding='same')(dropout)
    relu = keras.layers.ReLU()(conv2d)
    feature_thirdDegree = keras.layers.UpSampling2D((2,2))(relu)
        
 
 
    '''fourth layer'''
    conv2d = keras.layers.Conv2D(64,(3,3),padding='same')(keras.layers.concatenate([feature_secendDegree,feature_thirdDegree]))      
    dropout = keras.layers.Dropout(0.1)(conv2d)
    conv2d = keras.layers.Conv2D(64,(3,3),padding='same')(dropout)
    relu = keras.layers.ReLU()(conv2d) 
    feature_fourthDegree = keras.layers.UpSampling2D((2,2))(relu)
 
    return input,feature_firstDegree,feature_fourthDegree
 
 
  def Run(self,X_train,y_train,X,y):
    import sys
    from tensorflow import keras
    from tensorflow.keras.layers import Concatenate,Conv2D,MaxPooling2D,Dropout,Input
    import numpy as np
    import matplotlib.pyplot as plt
    np.set_printoptions(threshold=sys.maxsize)
        
        
    input,feature_firstDegree,feature_fourthDegree=self.u_net4blocks()
    input1,feature_firstDegree1,feature_fourthDegree1=self.u_net4blocks()
    '''input2,feature_firstDegree2,feature_fourthDegree2=self.u_net4blocks()
    input3,feature_firstDegree3,feature_fourthDegree3=self.u_net4blocks()'''
 
 
 
 
    '''fifth layer'''
    conv2d = keras.layers.Conv2D(32,(3,3),padding='same')(keras.layers.concatenate([feature_firstDegree,feature_fourthDegree,feature_firstDegree1,feature_fourthDegree1]))   
    dropout = keras.layers.Dropout(0.1)(conv2d)
    conv2d = keras.layers.Conv2D(32,(3,3),padding='same')(dropout)
    relu = keras.layers.ReLU()(conv2d)   
    conv2d = keras.layers.Conv2D(3,(1,1),padding='same')(relu)
 
    SoftMax = keras.layers.Softmax()(conv2d)
 
 
 
    Model_Net = keras.Model([input,input1],SoftMax,name='U-net')
    Model_Net.summary()
 
 
 
    opt = keras.optimizers.Adam(learning_rate=0.001,decay=1e-6)
    Model_Net.compile(loss = "categorical_crossentropy", optimizer = opt,metrics=[jaccard_distance_edema,dice_coef_edema,jaccard_distance_tumor,dice_coef_tumor])
    history = Model_Net.fit(X_train,y_train, epochs=100, batch_size=32,validation_data=(X,y))
    self.Model_Net = Model_Net
    self.Model_Net.save(f'./gdrive/MyDrive/{Model_path}/64.h5')
    return history
#,'SimBRATS_HG0001','SimBRATS_HG0002','SimBRATS_HG0003','SimBRATS_HG0004','SimBRATS_HG0005','SimBRATS_HG0006','SimBRATS_HG0007','SimBRATS_HG0008','SimBRATS_HG0009','SimBRATS_HG0010','SimBRATS_HG0011','SimBRATS_HG0012','SimBRATS_HG0013','SimBRATS_HG0014','SimBRATS_HG0015','SimBRATS_HG0016','SimBRATS_HG0017','SimBRATS_HG0018','SimBRATS_HG0019','SimBRATS_HG0020','SimBRATS_HG0021','SimBRATS_HG0022','SimBRATS_HG0023','SimBRATS_HG0024','SimBRATS_HG0025','SimBRATS_LG0001','SimBRATS_LG0002','SimBRATS_LG0003','SimBRATS_LG0004','SimBRATS_LG0005','SimBRATS_LG0006','SimBRATS_LG0007','SimBRATS_LG0008','SimBRATS_LG0009','SimBRATS_LG0010','SimBRATS_LG0011','SimBRATS_LG0012','SimBRATS_LG0013','SimBRATS_LG0014','SimBRATS_LG0015','SimBRATS_LG0016','SimBRATS_LG0017','SimBRATS_LG0018','SimBRATS_LG0019','SimBRATS_LG0020','SimBRATS_LG0020','SimBRATS_LG0021','SimBRATS_LG0022','SimBRATS_LG0023','SimBRATS_LG0024','SimBRATS_LG0025'
module = CreateSubImages(Brains=['BRATS_HG0001','BRATS_HG0002','BRATS_HG0003','BRATS_HG0004','BRATS_HG0005','BRATS_HG0006','BRATS_HG0007','BRATS_HG0008','BRATS_HG0009','BRATS_HG0010','BRATS_HG0011','BRATS_HG0012','BRATS_HG0013','BRATS_HG0014','BRATS_HG0015','BRATS_HG0022','BRATS_HG0024','BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0001','BRATS_LG0002','BRATS_LG0004','BRATS_LG0006','BRATS_LG0008','BRATS_LG0011','BRATS_LG0012','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015'],Type=['T1','T2','T1C','FLAIR'],shape=(64,64))
 
#module.Get_Images_With_Truths()

import numpy as np
import sys
 
np.set_printoptions(threshold=sys.maxsize) 
def turn3Channel(TruthsRelated):
  import numpy as np
  import os
 
 
 
  liste = np.array([0] * (TruthsRelated.shape[0]*TruthsRelated.shape[1]*TruthsRelated.shape[2]*3),dtype=np.int8).reshape(-1,64,64,3)
  for i in range(len(TruthsRelated)):
    for j in range(len(TruthsRelated[i])):
      for k in range(len(TruthsRelated[i][j])):
        if  0 <= TruthsRelated[i][j][k][0] <= 51:
          liste[i][j][k][0] = 1
        elif 51 < TruthsRelated[i][j][k][0] <= 204:
          liste[i][j][k][1] = 1
        elif 204 < TruthsRelated[i][j][k][0] <= 255:
          liste[i][j][k][2] = 1
  return liste
 
 
def Process_Data(Array,ArrayMask,Array2,Size):
  import numpy as np
  liste1 = []
  liste2 = []
  liste3 = []
  i = 0
  cpt = 0
  for L in range(len(Array)):
    for k in range(len(Array[L])):
      image = np.array(Array[L][k])
      mask = np.array(ArrayMask[L][k])
      image2 = np.array(Array2[L][k])
      for i in range(0,len(image),int(Size/2)):
        for j in range(0,len(image[i]),int(Size/2)):
          if image[i:i+Size,j:j+Size].shape == (Size,Size) and np.count_nonzero(mask[i:i+Size,j:j+Size]):
            s1 = image[i:i+Size,j:j+Size]
            liste1.append(s1.reshape(-1,Size,Size,1))
            s2 = mask[i:i+Size,j:j+Size]
            liste2.append(s2.reshape(-1,Size,Size,1))
            s3 = image2[i:i+Size,j:j+Size]
            liste3.append(s3.reshape(-1,Size,Size,1))
  nb_of_images = len(liste2)
  control = nb_of_images * 2
  for L in range(len(Array)):
    for k in range(len(Array[L])):
      image = np.array(Array[L][k])
      mask = np.array(ArrayMask[L][k])
      image2 = np.array(Array2[L][k])
      for i in range(0,len(image),int(Size/2)):
        for j in range(0,len(image[i]),int(Size/2)):
          if image[i:i+Size,j:j+Size].shape == (Size,Size) and np.count_nonzero(image[i:i+Size,j:j+Size]):
            if nb_of_images <= control:
              nb_of_images = nb_of_images + 1
              s1 = image[i:i+Size,j:j+Size]
              liste1.append(s1.reshape(-1,Size,Size,1))
              s2 = mask[i:i+Size,j:j+Size]
              liste2.append(s2.reshape(-1,Size,Size,1))
              s3 = image2[i:i+Size,j:j+Size]
              liste3.append(s3.reshape(-1,Size,Size,1))
  nb_of_images = len(liste2)
  control = nb_of_images * 1.5
  for L in range(len(Array)):
    for k in range(len(Array[L])):
      image = np.array(Array[L][k])
      mask = np.array(ArrayMask[L][k])
      image2 = np.array(Array2[L][k])

      for i in range(0,len(image),int(Size/2)):
        for j in range(0,len(image[i]),int(Size/2)):
          if image[i:i+Size,j:j+Size].shape == (Size,Size) and np.count_nonzero(image[i:i+Size,j:j+Size])==False and np.count_nonzero(image[i:i+Size,j:j+Size])==False:
            if nb_of_images < 40826:
              nb_of_images = nb_of_images + 1
              s1 = image[i:i+Size,j:j+Size]
              liste1.append(s1.reshape(-1,Size,Size,1))
              s2 = mask[i:i+Size,j:j+Size]
              liste2.append(s2.reshape(-1,Size,Size,1))
              s3 = image2[i:i+Size,j:j+Size]
              liste3.append(s3.reshape(-1,Size,Size,1))
          
  return np.array(liste1).reshape(-1,Size,Size,1),np.array(liste2).reshape(-1,Size,Size,1),np.array(liste3).reshape(-1,Size,Size,1)
 
 
Data1,Truths1=module.Load_Data('full',['BRATS_HG0001','BRATS_HG0002','BRATS_HG0003','BRATS_HG0004','BRATS_HG0005','BRATS_HG0006','BRATS_HG0007','BRATS_HG0008','BRATS_HG0009','BRATS_HG0010','BRATS_HG0011','BRATS_HG0012','BRATS_HG0013','BRATS_HG0014','BRATS_HG0015','BRATS_HG0024','BRATS_LG0001','BRATS_LG0002','BRATS_LG0004','BRATS_LG0006','BRATS_LG0008'],'T1C')

Data2,Truths2=module.Load_Data('full',['BRATS_HG0001','BRATS_HG0002','BRATS_HG0003','BRATS_HG0004','BRATS_HG0005','BRATS_HG0006','BRATS_HG0007','BRATS_HG0008','BRATS_HG0009','BRATS_HG0010','BRATS_HG0011','BRATS_HG0012','BRATS_HG0013','BRATS_HG0014','BRATS_HG0015','BRATS_HG0024','BRATS_LG0001','BRATS_LG0002','BRATS_LG0004','BRATS_LG0006','BRATS_LG0008'],'FLAIR')

Data3,Truths3=module.Load_Data('full',['BRATS_HG0001','BRATS_HG0002','BRATS_HG0003','BRATS_HG0004','BRATS_HG0005','BRATS_HG0006','BRATS_HG0007','BRATS_HG0008','BRATS_HG0009','BRATS_HG0010','BRATS_HG0011','BRATS_HG0012','BRATS_HG0013','BRATS_HG0014','BRATS_HG0015','BRATS_HG0024','BRATS_LG0001','BRATS_LG0002','BRATS_LG0004','BRATS_LG0006','BRATS_LG0008'],'T2')

Data4,Truths4=module.Load_Data('full',['BRATS_HG0001','BRATS_HG0002','BRATS_HG0003','BRATS_HG0004','BRATS_HG0005','BRATS_HG0006','BRATS_HG0007','BRATS_HG0008','BRATS_HG0009','BRATS_HG0010','BRATS_HG0011','BRATS_HG0012','BRATS_HG0013','BRATS_HG0014','BRATS_HG0015','BRATS_HG0024','BRATS_LG0001','BRATS_LG0002','BRATS_LG0004','BRATS_LG0006','BRATS_LG0008'],'T1')



Data11t1c,Truths11t1c = module.Load_Data('full',['BRATS_LG0011'],'T1C')
Data12t1c,Truths12t1c = module.Load_Data('full',['BRATS_LG0012'],'T1C')
Data22t1c,Truths22t1c = module.Load_Data('full',['BRATS_HG0022'],'T1C')
 
Data11f,Truths11f= module.Load_Data('full',['BRATS_LG0011'],'FLAIR')
Data12f,Truths12f = module.Load_Data('full',['BRATS_LG0012'],'FLAIR')
Data22f,Truths22f = module.Load_Data('full',['BRATS_HG0022'],'FLAIR')

Data11t2,Truths11t2= module.Load_Data('full',['BRATS_LG0011'],'T2')
Data12t2,Truths12t2 = module.Load_Data('full',['BRATS_LG0012'],'T2')
Data22t2,Truths22t2 = module.Load_Data('full',['BRATS_HG0022'],'T2')

Data11t1,Truths11t1 = module.Load_Data('full',['BRATS_LG0011'],'T1')
Data12t1,Truths12t1 = module.Load_Data('full',['BRATS_LG0012'],'T1')
Data22t1,Truths22t1 = module.Load_Data('full',['BRATS_HG0022'],'T1')


 
 
 
Data11t1c[0] = Data11t1c[0][:-7]
Truths11t1c[0] = Truths11t1c[0][:-7]
 
Data11f[0] = Data11f[0][1:]
Truths11f[0] = Truths11f[0][1:]

Data11t1[0] = Data11t1[0][:-7]
Truths11t1[0] = Truths11t1[0][:-7]

Data11t2[0] = Data11t2[0][:-2]
Truths11t2[0] = Truths11t2[0][:-2]
 
####

Data12t1c[0] = Data12t1c[0][:-2]
Truths12t1c[0] = Truths12t1c[0][:-2]
 
Data12f[0] = Data12f[0][1:-2]
Truths12f[0] = Truths12f[0][1:-2]

Data12t1[0] = Data12t1[0][:-2]
Truths12t1[0] = Truths12t1[0][:-2]

Data12t2[0] = Data12t2[0][:]
Truths12t2[0] = Truths12t2[0][:]
 


#####


Data22t1c[0] = Data22t1c[0][:-4]
Truths22t1c[0] = Truths22t1c[0][:-4]
 
Data22f[0] = Data22f[0][1:-5]
Truths22f[0] = Truths22f[0][1:-5]

Data22t1[0] = Data22t1[0][:-4]
Truths22t1[0] = Truths22t1[0][:-4]

Data22t2[0] = Data22t2[0][:]
Truths22t2[0] = Truths22t2[0][:]
 

 






 

 
Data1.append(Data11t1c[0])
Data1.append(Data12t1c[0])
Data1.append(Data22t1c[0])
 
Truths1.append(Truths11t1c[0])
Truths1.append(Truths12t1c[0])
Truths1.append(Truths22t1c[0])
 
Data2.append(Data11f[0])
Data2.append(Data12f[0])
Data2.append(Data22f[0])
 
 
Truths2.append(Truths11f[0])
Truths2.append(Truths12f[0])
Truths2.append(Truths22f[0])

Data3.append(Data11t1[0])
Data3.append(Data12t1[0])
Data3.append(Data22t1[0])
 
Truths3.append(Truths11t1[0])
Truths3.append(Truths12t1[0])
Truths3.append(Truths22t1[0])

Data4.append(Data11t2[0])
Data4.append(Data12t2[0])
Data4.append(Data22t2[0])
 
Truths4.append(Truths11t2[0])
Truths4.append(Truths12t2[0])
Truths4.append(Truths22t2[0])


Data1,Truths1,Data2 = Process_Data(Data1,Truths1,Data2,64)
Data3,Truths3,Data4 = Process_Data(Data3,Truths3,Data4,64)
print(Data1.shape)
print(Data2.shape)
print(Data3.shape)
print(Data4.shape)
Truths1 = turn3Channel(Truths1)
print(Truths1.shape)
 
 
'''for i in range(len(Data1)):
  print(len(Data1[i]))
  print(len(Data2[i]))
  print(len(Data3[i]))
  print(len(Data4[i]))
  if len(Data3[i]) == len(Data4[i]):
    print('yes !')
  else :
    print('wrong !')'''

Data1 = Data1 / 255.0
Data2 = Data2 / 255.0
Data3 = Data3 / 255.0
Data4 = Data4 / 255.0

import numpy as np
 
X_test,y_test = module.Load_Data('full',['BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015'],'T1C')
X_test1,y_test1 = module.Load_Data('full',['BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015'],'FLAIR')
X_test2,y_test2 = module.Load_Data('full',['BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015'],'T2')
X_test3,y_test3 = module.Load_Data('full',['BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015'],'T1')

X_test[0] = X_test[0][:-4]
y_test[0] = y_test[0][:-4]

X_test1[0] = X_test1[0][:-4]
y_test1[0] = y_test1[0][:-4]

X_test2[0] = X_test2[0][:]
y_test2[0] = y_test2[0][:]

X_test3[0] = X_test3[0][:-4]
y_test3[0] = y_test3[0][:-4]

X_test[2] = X_test[2][:-1]
y_test[2] = y_test[2][:-1]

X_test1[2] = X_test1[2][:]
y_test1[2] = y_test1[2][:]

X_test2[2] = X_test2[2][:]
y_test2[2] = y_test2[2][:]

X_test3[2] = X_test3[2][:-1]
y_test3[2] = y_test3[2][:-1]


X_test[3] = X_test[3][:-1]
y_test[3] = y_test[3][:-1]

X_test1[3] = X_test1[3][:-1]
y_test1[3] = y_test1[3][:-1]

X_test2[3] = X_test2[3][:]
y_test2[3] = y_test2[3][:]

X_test3[3] = X_test3[3][:-1]
y_test3[3] = y_test3[3][:-1]


X_test[4] = X_test[4][:-2]
y_test[4] = y_test[4][:-2]

X_test1[4] = X_test1[4][:-2]
y_test1[4] = y_test1[4][:-2]

X_test2[4] = X_test2[4][:]
y_test2[4] = y_test2[4][:]

X_test3[4] = X_test3[4][:-2]
y_test3[4] = y_test3[4][:-2]

X_test[5] = X_test[5][2:-1]
y_test[5] = y_test[5][2:-1]

X_test1[5] = X_test1[5][2:-1]
y_test1[5] = y_test1[5][2:-1]

X_test2[5] = X_test2[5][:]
y_test2[5] = y_test2[5][:]

X_test3[5] = X_test3[5][2:-1]
y_test3[5] = y_test3[5][2:-1]

'''for i in range(len(X_test)):
  print(len(X_test[i]))
  print(len(X_test1[i]))
  print(len(X_test2[i]))
  print(len(X_test3[i]))
  if len(X_test2[i]) == len(X_test3[i]):
    print('yes !')
  else :
    print('wrong !')'''
def Process_Data(Array,ArrayMask,Array2,Size):
  import numpy as np
  liste1 = []
  liste2 = []
  liste3 = []
  i = 0
  cpt = 0
  for L in range(len(Array)):
    for k in range(len(Array[L])):
      image = np.array(Array[L][k])
      mask = np.array(ArrayMask[L][k])
      image2 = np.array(Array2[L][k])
      for i in range(0,len(image),int(Size)):
        for j in range(0,len(image[i]),int(Size)):
          if image[i:i+Size,j:j+Size].shape == (Size,Size) and np.count_nonzero(mask[i:i+Size,j:j+Size]):
            s1 = image[i:i+Size,j:j+Size]
            liste1.append(s1.reshape(-1,Size,Size,1))
            s2 = mask[i:i+Size,j:j+Size]
            liste2.append(s2.reshape(-1,Size,Size,1))
            s3 = image2[i:i+Size,j:j+Size]
            liste3.append(s3.reshape(-1,Size,Size,1))
  nb_of_images = len(liste2)
  control = nb_of_images * 2
  for L in range(len(Array)):
    for k in range(len(Array[L])):
      image = np.array(Array[L][k])
      mask = np.array(ArrayMask[L][k])
      image2 = np.array(Array2[L][k])
      for i in range(0,len(image),int(Size)):
        for j in range(0,len(image[i]),int(Size)):
          if image[i:i+Size,j:j+Size].shape == (Size,Size) and np.count_nonzero(image[i:i+Size,j:j+Size]):
            if nb_of_images <= control:
              nb_of_images = nb_of_images + 1
              s1 = image[i:i+Size,j:j+Size]
              liste1.append(s1.reshape(-1,Size,Size,1))
              s2 = mask[i:i+Size,j:j+Size]
              liste2.append(s2.reshape(-1,Size,Size,1))
              s3 = image2[i:i+Size,j:j+Size]
              liste3.append(s3.reshape(-1,Size,Size,1))
  nb_of_images = len(liste2)
  control = nb_of_images * 1.2
  for L in range(len(Array)):
    for k in range(len(Array[L])):
      image = np.array(Array[L][k])
      mask = np.array(ArrayMask[L][k])
      image2 = np.array(Array2[L][k])

      for i in range(0,len(image),int(Size)):
        for j in range(0,len(image[i]),int(Size)):
          if image[i:i+Size,j:j+Size].shape == (Size,Size) and np.count_nonzero(image[i:i+Size,j:j+Size])==False and np.count_nonzero(image[i:i+Size,j:j+Size])==False:
            if nb_of_images < control:
              nb_of_images = nb_of_images + 1
              s1 = image[i:i+Size,j:j+Size]
              liste1.append(s1.reshape(-1,Size,Size,1))
              s2 = mask[i:i+Size,j:j+Size]
              liste2.append(s2.reshape(-1,Size,Size,1))
              s3 = image2[i:i+Size,j:j+Size]
              liste3.append(s3.reshape(-1,Size,Size,1))
          
  return np.array(liste1).reshape(-1,Size,Size,1),np.array(liste2).reshape(-1,Size,Size,1),np.array(liste3).reshape(-1,Size,Size,1)



X_test,y_test,X_test1 = Process_Data(X_test,y_test,X_test1,64)
X_test2,y_test2,X_test3 = Process_Data(X_test2,y_test2,X_test3,64)
y_test = turn3Channel(y_test)
X_test = X_test / 255.0
X_test1 = X_test1 / 255.0
X_test2 = X_test2 / 255.0
X_test3 = X_test3 / 255.0

from tensorflow import keras
keras.backend.clear_session()
# Data1 = T1C , Data2 = FLAIR , Data3 = T2 , Data4 = T1
# X_test = T1C , X_test1 = FLAIR , X_test2 = T2 , X_test3 = T1
history = module.Run([Data4,Data3],Truths1,[X_test3,X_test2],y_test)

import matplotlib.pyplot as plt
 
plt.plot(history.history['dice_coef_edema'])
plt.plot(history.history['val_dice_coef_edema'])
plt.title('model dice coefficent for edma')
plt.ylabel('dice coefficent')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.savefig(f'./gdrive/MyDrive/{Model_path}/dice1.png')
 
plt.clf()
plt.cla()
plt.close()

plt.plot(history.history['jaccard_distance_edema'])
plt.plot(history.history['val_jaccard_distance_edema'])
plt.title('model jaccard distance edma')
plt.ylabel('jaccard distance')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.savefig(f'./gdrive/MyDrive/{Model_path}/jaccard1.png')

plt.clf()
plt.cla()
plt.close()

plt.plot(history.history['dice_coef_tumor'])
plt.plot(history.history['val_dice_coef_tumor'])
plt.title('model dice coefficent for tumor')
plt.ylabel('dice coefficent')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.savefig(f'./gdrive/MyDrive/{Model_path}/dice2.png')
 
plt.clf()
plt.cla()
plt.close()

plt.plot(history.history['jaccard_distance_tumor'])
plt.plot(history.history['val_jaccard_distance_tumor'])
plt.title('model jaccard distance tumor')
plt.ylabel('jaccard distance')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.savefig(f'./gdrive/MyDrive/{Model_path}/jaccard2.png')

plt.clf()
plt.cla()
plt.close()

mods = ['T1CFLAIR','T1CT2','T1FLAIR','T1T1C','T1T2','T2FLAIR']
values_of_dice_tumor = []
values_of_jaccard_tumor = []
values_of_dice_edema = []
values_of_jaccard_edema = []
real_dice = []
real_jaccard = []
def Process_Data(Array,ArrayMask,Array2,Size):
    import numpy as np
    liste1 = []
    liste2 = []
    liste3 = []
    i = 0
    cpt = 0
    
    for k in range(len(Array)):
      image = np.array(Array[k])
      mask = np.array(ArrayMask[k])
      image2 = np.array(Array2[k])
      for i in range(0,len(image),Size):
        for j in range(0,len(image[i]),Size):
          if image[i:i+Size,j:j+Size].shape == (Size,Size) and np.count_nonzero(mask[i:i+Size,j:j+Size]):
            s1 = image[i:i+Size,j:j+Size]
            liste1.append(s1.reshape(-1,Size,Size,1))
            s2 = mask[i:i+Size,j:j+Size]
            liste2.append(s2.reshape(-1,Size,Size,1))
            s3 = image2[i:i+Size,j:j+Size]
            liste3.append(s3.reshape(-1,Size,Size,1))
    nb_of_images = len(liste2)
    control = nb_of_images * 2
    for k in range(len(Array)):
      image = np.array(Array[k])
      mask = np.array(ArrayMask[k])
      image2 = np.array(Array2[k])
      for i in range(0,len(image),Size):
        for j in range(0,len(image[i]),Size):
          if image[i:i+Size,j:j+Size].shape == (Size,Size) and np.count_nonzero(image[i:i+Size,j:j+Size]):
            if nb_of_images <= control:
              nb_of_images = nb_of_images + 1
              s1 = image[i:i+Size,j:j+Size]
              liste1.append(s1.reshape(-1,Size,Size,1))
              s2 = mask[i:i+Size,j:j+Size]
              liste2.append(s2.reshape(-1,Size,Size,1))
              s3 = image2[i:i+Size,j:j+Size]
              liste3.append(s3.reshape(-1,Size,Size,1))
    nb_of_images = len(liste2)
    return np.array(liste1).reshape(-1,Size,Size,1),np.array(liste2).reshape(-1,Size,Size,1),np.array(liste3).reshape(-1,Size,Size,1)
X_test,y_test = module.Load_Data('full',['BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015','BRATS_HG0001','BRATS_HG0008','BRATS_LG0006','BRATS_LG0008'],'T1C')
X_test1,y_test1 = module.Load_Data('full',['BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015','BRATS_HG0001','BRATS_HG0008','BRATS_LG0006','BRATS_LG0008'],'FLAIR')
X_test2,y_test2 = module.Load_Data('full',['BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015','BRATS_HG0001','BRATS_HG0008','BRATS_LG0006','BRATS_LG0008'],'T2')
X_test3,y_test3 = module.Load_Data('full',['BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015','BRATS_HG0001','BRATS_HG0008','BRATS_LG0006','BRATS_LG0008'],'T1')

X_test[0] = X_test[0][:-4]
y_test[0] = y_test[0][:-4]

X_test1[0] = X_test1[0][:-4]
y_test1[0] = y_test1[0][:-4]

X_test2[0] = X_test2[0][:]
y_test2[0] = y_test2[0][:]

X_test3[0] = X_test3[0][:-4]
y_test3[0] = y_test3[0][:-4]

X_test[2] = X_test[2][:-1]
y_test[2] = y_test[2][:-1]

X_test1[2] = X_test1[2][:]
y_test1[2] = y_test1[2][:]

X_test2[2] = X_test2[2][:]
y_test2[2] = y_test2[2][:]

X_test3[2] = X_test3[2][:-1]
y_test3[2] = y_test3[2][:-1]


X_test[3] = X_test[3][:-1]
y_test[3] = y_test[3][:-1]

X_test1[3] = X_test1[3][:-1]
y_test1[3] = y_test1[3][:-1]

X_test2[3] = X_test2[3][:]
y_test2[3] = y_test2[3][:]

X_test3[3] = X_test3[3][:-1]
y_test3[3] = y_test3[3][:-1]


X_test[4] = X_test[4][:-2]
y_test[4] = y_test[4][:-2]

X_test1[4] = X_test1[4][:-2]
y_test1[4] = y_test1[4][:-2]

X_test2[4] = X_test2[4][:]
y_test2[4] = y_test2[4][:]

X_test3[4] = X_test3[4][:-2]
y_test3[4] = y_test3[4][:-2]

X_test[5] = X_test[5][2:-1]
y_test[5] = y_test[5][2:-1]

X_test1[5] = X_test1[5][2:-1]
y_test1[5] = y_test1[5][2:-1]

X_test2[5] = X_test2[5][:]
y_test2[5] = y_test2[5][:]

X_test3[5] = X_test3[5][2:-1]
y_test3[5] = y_test3[5][2:-1]

for mod in mods:
  from tensorflow.keras import models,optimizers
  import numpy as np
  import os
  def turn3Channel(TruthsRelated):  
    liste = [0] * (TruthsRelated.shape[0]*TruthsRelated.shape[1]*TruthsRelated.shape[2]*3)
    liste = np.array(liste).reshape(-1,64,64,3)
    for i in range(len(TruthsRelated)):
      for j in range(len(TruthsRelated[i])):
        for k in range(len(TruthsRelated[i][j])):
          if  0 <= TruthsRelated[i][j][k] <= 51:
            liste[i][j][k][0] = 1
          elif 51 < TruthsRelated[i][j][k] <= 204:
            liste[i][j][k][1] = 1
          elif 204 < TruthsRelated[i][j][k] <= 255:
            liste[i][j][k][2] = 1
    return liste

            
    return np.array(liste1).reshape(-1,Size,Size,1),np.array(liste2).reshape(-1,Size,Size,1),np.array(liste3).reshape(-1,Size,Size,1)
  '''BRATS_HG0001','BRATS_HG0015','BRATS_LG0006','BRATS_LG0008','''

  '''BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015'''
  def turn1Channel(TruthsRelated):
    import numpy as np
    liste = [[0 for _ in range(64)] for _ in range(64)]
    for i in range(len(TruthsRelated)):
      for j in range(len(TruthsRelated[i])):
        for k in range(len(TruthsRelated[i][j])):
          if 0.5 <= TruthsRelated[i][j][k][0] <= 1:
            liste[j][k] = 0
          elif 0.5 <= TruthsRelated[i][j][k][1] <= 1:
            liste[j][k] = 124
          elif 0.5 <= TruthsRelated[i][j][k][2] <= 1:
            liste[j][k] = 255
    return np.array(liste)
  d = models.load_model(f'./gdrive/MyDrive/{mod}/64.h5',custom_objects={"dice_coef_edema":dice_coef_edema,"jaccard_distance_edema":jaccard_distance_edema,"dice_coef_tumor":dice_coef_tumor,"jaccard_distance_tumor":jaccard_distance_tumor})

  opt = optimizers.Adam(learning_rate=0.0001,decay=1e-6)

  d.compile(loss = "categorical_crossentropy", optimizer = opt,metrics=[jaccard_distance_edema,dice_coef_edema,jaccard_distance_tumor,dice_coef_tumor])
  import matplotlib.pyplot as plt


  '''for i in range(0,len(X_test)):
    x1 = d.predict([X_test3[i].reshape(-1,64,64,1),X_test2[i].reshape(-1,64,64,1)])
    x1 = turn1Channel(x1)
    plt.imsave(f'./gdrive/MyDrive/{Model_path}/{i}_predict.png',x1,cmap='gray')


    plt.imsave(f'./gdrive/MyDrive/{Model_path}/{i}_truth.png',y_test2[i].reshape(64,64),cmap='gray')

  for i in range(0,len(X_test)):
    x1 = d.predict([X_test3[i].reshape(-1,64,64,1),X_test2[i].reshape(-1,64,64,1)])
    x1 = turn1Channel(x1)
    plt.imshow(X_test1[i].reshape(64,64),cmap='gray')
    plt.show()



    plt.imshow(y_test2[i].reshape(64,64),cmap='gray')
    plt.show()'''
  values_of_dice_tumor = []
  values_of_jaccard_tumor = []
  values_of_dice_edema = []
  values_of_jaccard_edema = []
  if mod == 'T1':
      print(f'{mod}')  
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)   
        _,je,de,jt,dt = d.evaluate(fourth,truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)
    
  if mod == 'T2':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate(third,truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)
  if mod == 'FLAIR':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate(secend,truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)
  if mod == 'T1C':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate(first,truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)
  if mod == 'T1CFLAIR':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate([first,secend],truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)
  if mod == 'T1CT2':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate([first,third],truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)
  if mod == 'T1FLAIR':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate([fourth,secend],truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)
  if mod == 'T1T1C':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate([fourth,first],truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)   
  if mod == 'T1T2':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate([fourth,third],truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)  
  if mod == 'T2FLAIR':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate([third,secend],truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)
  real_dice.extend(values_of_dice_tumor)
  real_dice.extend(values_of_dice_edema)
  real_jaccard.extend(values_of_jaccard_tumor)
  real_jaccard.extend(values_of_jaccard_edema)

mods = ['T1','T1C','T2','FLAIR']
values_of_dice_tumor = []
values_of_jaccard_tumor = []
values_of_dice_edema = []
values_of_jaccard_edema = []
real_dice = []
real_jaccard = []
def Process_Data(Array,ArrayMask,Array2,Size):
    import numpy as np
    liste1 = []
    liste2 = []
    liste3 = []
    i = 0
    cpt = 0
    
    for k in range(len(Array)):
      image = np.array(Array[k])
      mask = np.array(ArrayMask[k])
      image2 = np.array(Array2[k])
      for i in range(0,len(image),Size):
        for j in range(0,len(image[i]),Size):
          if image[i:i+Size,j:j+Size].shape == (Size,Size) and np.count_nonzero(mask[i:i+Size,j:j+Size]):
            s1 = image[i:i+Size,j:j+Size]
            liste1.append(s1.reshape(-1,Size,Size,1))
            s2 = mask[i:i+Size,j:j+Size]
            liste2.append(s2.reshape(-1,Size,Size,1))
            s3 = image2[i:i+Size,j:j+Size]
            liste3.append(s3.reshape(-1,Size,Size,1))
    nb_of_images = len(liste2)
    control = nb_of_images * 2
    for k in range(len(Array)):
      image = np.array(Array[k])
      mask = np.array(ArrayMask[k])
      image2 = np.array(Array2[k])
      for i in range(0,len(image),Size):
        for j in range(0,len(image[i]),Size):
          if image[i:i+Size,j:j+Size].shape == (Size,Size) and np.count_nonzero(image[i:i+Size,j:j+Size]):
            if nb_of_images <= control:
              nb_of_images = nb_of_images + 1
              s1 = image[i:i+Size,j:j+Size]
              liste1.append(s1.reshape(-1,Size,Size,1))
              s2 = mask[i:i+Size,j:j+Size]
              liste2.append(s2.reshape(-1,Size,Size,1))
              s3 = image2[i:i+Size,j:j+Size]
              liste3.append(s3.reshape(-1,Size,Size,1))
    nb_of_images = len(liste2)
    return np.array(liste1).reshape(-1,Size,Size,1),np.array(liste2).reshape(-1,Size,Size,1),np.array(liste3).reshape(-1,Size,Size,1)
X_test,y_test = module.Load_Data('full',['BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015','BRATS_HG0001','BRATS_HG0015','BRATS_LG0006','BRATS_LG0008'],'T1C')
X_test1,y_test1 = module.Load_Data('full',['BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015','BRATS_HG0001','BRATS_HG0015','BRATS_LG0006','BRATS_LG0008'],'FLAIR')
X_test2,y_test2 = module.Load_Data('full',['BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015','BRATS_HG0001','BRATS_HG0015','BRATS_LG0006','BRATS_LG0008'],'T2')
X_test3,y_test3 = module.Load_Data('full',['BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015','BRATS_HG0001','BRATS_HG0015','BRATS_LG0006','BRATS_LG0008'],'T1')

X_test[0] = X_test[0][:-4]
y_test[0] = y_test[0][:-4]

X_test1[0] = X_test1[0][:-4]
y_test1[0] = y_test1[0][:-4]

X_test2[0] = X_test2[0][:]
y_test2[0] = y_test2[0][:]

X_test3[0] = X_test3[0][:-4]
y_test3[0] = y_test3[0][:-4]

X_test[2] = X_test[2][:-1]
y_test[2] = y_test[2][:-1]

X_test1[2] = X_test1[2][:]
y_test1[2] = y_test1[2][:]

X_test2[2] = X_test2[2][:]
y_test2[2] = y_test2[2][:]

X_test3[2] = X_test3[2][:-1]
y_test3[2] = y_test3[2][:-1]


X_test[3] = X_test[3][:-1]
y_test[3] = y_test[3][:-1]

X_test1[3] = X_test1[3][:-1]
y_test1[3] = y_test1[3][:-1]

X_test2[3] = X_test2[3][:]
y_test2[3] = y_test2[3][:]

X_test3[3] = X_test3[3][:-1]
y_test3[3] = y_test3[3][:-1]


X_test[4] = X_test[4][:-2]
y_test[4] = y_test[4][:-2]

X_test1[4] = X_test1[4][:-2]
y_test1[4] = y_test1[4][:-2]

X_test2[4] = X_test2[4][:]
y_test2[4] = y_test2[4][:]

X_test3[4] = X_test3[4][:-2]
y_test3[4] = y_test3[4][:-2]

X_test[5] = X_test[5][2:-1]
y_test[5] = y_test[5][2:-1]

X_test1[5] = X_test1[5][2:-1]
y_test1[5] = y_test1[5][2:-1]

X_test2[5] = X_test2[5][:]
y_test2[5] = y_test2[5][:]

X_test3[5] = X_test3[5][2:-1]
y_test3[5] = y_test3[5][2:-1]

for mod in mods:
  from tensorflow.keras import models,optimizers
  import numpy as np
  import os
  def turn3Channel(TruthsRelated):  
    liste = [0] * (TruthsRelated.shape[0]*TruthsRelated.shape[1]*TruthsRelated.shape[2]*3)
    liste = np.array(liste).reshape(-1,64,64,3)
    for i in range(len(TruthsRelated)):
      for j in range(len(TruthsRelated[i])):
        for k in range(len(TruthsRelated[i][j])):
          if  0 <= TruthsRelated[i][j][k] <= 51:
            liste[i][j][k][0] = 1
          elif 51 < TruthsRelated[i][j][k] <= 204:
            liste[i][j][k][1] = 1
          elif 204 < TruthsRelated[i][j][k] <= 255:
            liste[i][j][k][2] = 1
    return liste

            
    return np.array(liste1).reshape(-1,Size,Size,1),np.array(liste2).reshape(-1,Size,Size,1),np.array(liste3).reshape(-1,Size,Size,1)
  '''BRATS_HG0001','BRATS_HG0015','BRATS_LG0006','BRATS_LG0008','''

  '''BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015'''
  def turn1Channel(TruthsRelated):
    import numpy as np
    liste = [[0 for _ in range(64)] for _ in range(64)]
    for i in range(len(TruthsRelated)):
      for j in range(len(TruthsRelated[i])):
        for k in range(len(TruthsRelated[i][j])):
          if 0.5 <= TruthsRelated[i][j][k][0] <= 1:
            liste[j][k] = 0
          elif 0.5 <= TruthsRelated[i][j][k][1] <= 1:
            liste[j][k] = 124
          elif 0.5 <= TruthsRelated[i][j][k][2] <= 1:
            liste[j][k] = 255
    return np.array(liste)
  d = models.load_model(f'./gdrive/MyDrive/{mod}/64.h5',custom_objects={"dice_coef_edema":dice_coef_edema,"jaccard_distance_edema":jaccard_distance_edema,"dice_coef_tumor":dice_coef_tumor,"jaccard_distance_tumor":jaccard_distance_tumor})

  opt = optimizers.Adam(learning_rate=0.0001,decay=1e-6)

  d.compile(loss = "categorical_crossentropy", optimizer = opt,metrics=[jaccard_distance_edema,dice_coef_edema,jaccard_distance_tumor,dice_coef_tumor])
  import matplotlib.pyplot as plt


  '''for i in range(0,len(X_test)):
    x1 = d.predict([X_test3[i].reshape(-1,64,64,1),X_test2[i].reshape(-1,64,64,1)])
    x1 = turn1Channel(x1)
    plt.imsave(f'./gdrive/MyDrive/{Model_path}/{i}_predict.png',x1,cmap='gray')


    plt.imsave(f'./gdrive/MyDrive/{Model_path}/{i}_truth.png',y_test2[i].reshape(64,64),cmap='gray')

  for i in range(0,len(X_test)):
    x1 = d.predict([X_test3[i].reshape(-1,64,64,1),X_test2[i].reshape(-1,64,64,1)])
    x1 = turn1Channel(x1)
    plt.imshow(X_test1[i].reshape(64,64),cmap='gray')
    plt.show()



    plt.imshow(y_test2[i].reshape(64,64),cmap='gray')
    plt.show()'''
  values_of_dice_tumor = []
  values_of_jaccard_tumor = []
  values_of_dice_edema = []
  values_of_jaccard_edema = []
  if mod == 'T1':
      print(f'{mod}')  
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)   
        _,je,de,jt,dt = d.evaluate(fourth,truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)
    
  if mod == 'T2':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate(third,truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)
  if mod == 'FLAIR':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate(secend,truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)
  if mod == 'T1C':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate(first,truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)
  if mod == 'T1CFLAIR':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate([first,secend],truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)
  if mod == 'T1CT2':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate([first,third],truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)
  if mod == 'T1FLAIR':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate([fourth,secend],truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)
  if mod == 'T1T1C':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate([fourth,first],truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)   
  if mod == 'T1T2':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate([fourth,third],truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)  
  if mod == 'T2FLAIR':
      print(f'{mod}')
      for i in range(10):
        first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
        third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
        truth = turn3Channel(truth)
        _,je,de,jt,dt = d.evaluate([third,secend],truth)
        values_of_dice_tumor.append(dt)
        values_of_jaccard_tumor.append(jt)
        values_of_dice_edema.append(de)
        values_of_jaccard_edema.append(je)
  real_dice.extend(values_of_dice_tumor)
  real_dice.extend(values_of_dice_edema)
  real_jaccard.extend(values_of_jaccard_tumor)
  real_jaccard.extend(values_of_jaccard_edema)

import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
"""l1 = ['T1'] * 20
l2 = ['T1C'] * 20
l3 = ['T2'] * 20
l4 = ['FLAIR'] * 20
"""
l5 = ['T1CFLAIR'] * 20
l6 = ['T1CT2'] * 20
l7 = ['T1FLAIR'] * 20
l8 = ['T1T1C'] * 20
l9 = ['T1T2'] * 20
l10 = ['T2FLAIR'] * 20

liste_for_type = []
"""liste_for_type.extend(l1)
liste_for_type.extend(l2)
liste_for_type.extend(l3)
liste_for_type.extend(l4)
"""
liste_for_type.extend(l5)
liste_for_type.extend(l6)
liste_for_type.extend(l7)
liste_for_type.extend(l8)
liste_for_type.extend(l9)
liste_for_type.extend(l10)

tumor = ['tumor'] * 5
edema = ['edema'] * 5
liste_for_case = []
liste_for_case.extend(tumor)
liste_for_case.extend(edema)
liste_for_case.extend(liste_for_case)
liste_for_case.extend(liste_for_case)
liste_for_case.extend(liste_for_case)
'''liste_for_case.extend(liste_for_case)'''
liste_for_case.extend(tumor)
liste_for_case.extend(edema)
liste_for_case.extend(tumor)
liste_for_case.extend(edema)
liste_for_case.extend(tumor)
liste_for_case.extend(edema)
liste_for_case.extend(tumor)
liste_for_case.extend(edema)


'''liste_HG_LG = []
HG = ['HG'] * 3
LG = ['LG'] * 3
liste_HG_LG.extend(HG)
liste_HG_LG.extend(LG)
liste_HG_LG.extend(liste_HG_LG)
liste_HG_LG.extend(liste_HG_LG)
liste_HG_LG.extend(liste_HG_LG)
liste_HG_LG.extend(liste_HG_LG)
liste_HG_LG.extend(HG)
liste_HG_LG.extend(LG)
liste_HG_LG.extend(HG)
liste_HG_LG.extend(LG)
liste_HG_LG.extend(HG)
liste_HG_LG.extend(LG)
liste_HG_LG.extend(HG)
liste_HG_LG.extend(LG)'''

print(len(liste_for_type))
print(len(liste_for_case))
'''print(len(liste_HG_LG))'''
print(len(real_dice))
print(len(real_jaccard))


data = {'type':liste_for_type,'case':liste_for_case,'jaccard':real_jaccard,'dice':real_dice}
df = pd.DataFrame(data)

sns.boxplot(x="case",y="dice",hue="type",data=df,palette="Set3")
plt.savefig('dice_merge.png')

mods = 'T1FLAIR'
values_of_dice_tumor = []
values_of_jaccard_tumor = []
values_of_dice_edema = []
values_of_jaccard_edema = []
real_dice = []
real_jaccard = []
def Process_Data(Array,ArrayMask,Array2,Size):
    import numpy as np
    liste1 = []
    liste2 = []
    liste3 = []
    i = 0
    cpt = 0
    for l in range(len(Array)):
      for k in range(len(Array[l])):
        image = np.array(Array[l][k])
        mask = np.array(ArrayMask[l][k])
        image2 = np.array(Array2[l][k])
        for i in range(0,len(image),int(Size/2)):
          for j in range(0,len(image[i]),int(Size/2)):
            if image[i:i+Size,j:j+Size].shape == (Size,Size) and np.count_nonzero(mask[i:i+Size,j:j+Size]):
              s1 = image[i:i+Size,j:j+Size]
              liste1.append(s1.reshape(-1,Size,Size,1))
              s2 = mask[i:i+Size,j:j+Size]
              liste2.append(s2.reshape(-1,Size,Size,1))
              s3 = image2[i:i+Size,j:j+Size]
              liste3.append(s3.reshape(-1,Size,Size,1))
    nb_of_images = len(liste2)
    control = nb_of_images * 2
    for l in range(len(Array)):
      for k in range(len(Array[l])):
        image = np.array(Array[l][k])
        mask = np.array(ArrayMask[l][k])
        image2 = np.array(Array2[l][k])
        for i in range(0,len(image),int(Size/2)):
          for j in range(0,len(image[i]),int(Size/2)):
            if image[i:i+Size,j:j+Size].shape == (Size,Size) and np.count_nonzero(image[i:i+Size,j:j+Size]):
              if nb_of_images <= control:
                nb_of_images = nb_of_images + 1
                s1 = image[i:i+Size,j:j+Size]
                liste1.append(s1.reshape(-1,Size,Size,1))
                s2 = mask[i:i+Size,j:j+Size]
                liste2.append(s2.reshape(-1,Size,Size,1))
                s3 = image2[i:i+Size,j:j+Size]
                liste3.append(s3.reshape(-1,Size,Size,1))
    nb_of_images = len(liste2)
    control = nb_of_images * 1.1
    for l in range(len(Array)):
      for k in range(len(Array[l])):
        image = np.array(Array[l][k])
        mask = np.array(ArrayMask[l][k])
        image2 = np.array(Array2[l][k])

        for i in range(0,len(image),int(Size/2)):
          for j in range(0,len(image[i]),int(Size/2)):
            if image[i:i+Size,j:j+Size].shape == (Size,Size) and np.count_nonzero(image[i:i+Size,j:j+Size])==False and np.count_nonzero(image[i:i+Size,j:j+Size])==False:
              if nb_of_images < control:
                nb_of_images = nb_of_images + 1
                s1 = image[i:i+Size,j:j+Size]
                liste1.append(s1.reshape(-1,Size,Size,1))
                s2 = mask[i:i+Size,j:j+Size]
                liste2.append(s2.reshape(-1,Size,Size,1))
                s3 = image2[i:i+Size,j:j+Size]
                liste3.append(s3.reshape(-1,Size,Size,1))
    return np.array(liste1).reshape(-1,Size,Size,1),np.array(liste2).reshape(-1,Size,Size,1),np.array(liste3).reshape(-1,Size,Size,1)

X_test,y_test = module.Load_Data('full',['BRATS_LG0013','BRATS_LG0014','BRATS_LG0015'],'T1C')
X_test1,y_test1 = module.Load_Data('full',['BRATS_LG0013','BRATS_LG0014','BRATS_LG0015'],'FLAIR')
X_test2,y_test2 = module.Load_Data('full',['BRATS_LG0013','BRATS_LG0014','BRATS_LG0015'],'T2')
X_test3,y_test3 = module.Load_Data('full',['BRATS_LG0013','BRATS_LG0014','BRATS_LG0015'],'T1')




X_test[0] = X_test[0][:-1]
y_test[0] = y_test[0][:-1]

X_test1[0] = X_test1[0][:-1]
y_test1[0] = y_test1[0][:-1]

X_test2[0] = X_test2[0][:]
y_test2[0] = y_test2[0][:]

X_test3[0] = X_test3[0][:-1]
y_test3[0] = y_test3[0][:-1]


X_test[1] = X_test[1][:-2]
y_test[1] = y_test[1][:-2]

X_test1[1] = X_test1[1][:-2]
y_test1[1] = y_test1[1][:-2]

X_test2[1] = X_test2[1][:]
y_test2[1] = y_test2[1][:]

X_test3[1] = X_test3[1][:-2]
y_test3[1] = y_test3[1][:-2]

X_test[2] = X_test[2][2:-1]
y_test[2] = y_test[2][2:-1]

X_test1[2] = X_test1[2][2:-1]
y_test1[2] = y_test1[2][2:-1]

X_test2[2] = X_test2[2][:]
y_test2[2] = y_test2[2][:]

X_test3[2] = X_test3[2][2:-1]
y_test3[2] = y_test3[2][2:-1]

from tensorflow.keras import models,optimizers
import numpy as np
import os
def turn3Channel(TruthsRelated):  
    liste = [0] * (TruthsRelated.shape[0]*TruthsRelated.shape[1]*TruthsRelated.shape[2]*3)
    liste = np.array(liste).reshape(-1,64,64,3)
    for i in range(len(TruthsRelated)):
      for j in range(len(TruthsRelated[i])):
        for k in range(len(TruthsRelated[i][j])):
          if  0 <= TruthsRelated[i][j][k] <= 51:
            liste[i][j][k][0] = 1
          elif 51 < TruthsRelated[i][j][k] <= 204:
            liste[i][j][k][1] = 1
          elif 204 < TruthsRelated[i][j][k] <= 255:
            liste[i][j][k][2] = 1
    return liste

            
    return np.array(liste1).reshape(-1,Size,Size,1),np.array(liste2).reshape(-1,Size,Size,1),np.array(liste3).reshape(-1,Size,Size,1)
'''BRATS_HG0001','BRATS_HG0015','BRATS_LG0006','BRATS_LG0008','''

'''BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015'''
def turn1Channel(TruthsRelated):
    import numpy as np
    liste = [[0 for _ in range(64)] for _ in range(64)]
    for i in range(len(TruthsRelated)):
      for j in range(len(TruthsRelated[i])):
        for k in range(len(TruthsRelated[i][j])):
          if 0.5 <= TruthsRelated[i][j][k][0] <= 1:
            liste[j][k] = 0
          elif 0.5 <= TruthsRelated[i][j][k][1] <= 1:
            liste[j][k] = 124
          elif 0.5 <= TruthsRelated[i][j][k][2] <= 1:
            liste[j][k] = 255
    return np.array(liste)
d = models.load_model(f'./gdrive/MyDrive/{mods}/64.h5',custom_objects={"dice_coef_edema":dice_coef_edema,"jaccard_distance_edema":jaccard_distance_edema,"dice_coef_tumor":dice_coef_tumor,"jaccard_distance_tumor":jaccard_distance_tumor})

opt = optimizers.Adam(learning_rate=0.0001,decay=1e-6)

d.compile(loss = "categorical_crossentropy", optimizer = opt,metrics=[jaccard_distance_edema,dice_coef_edema,jaccard_distance_tumor,dice_coef_tumor])
import matplotlib.pyplot as plt


'''  for i in range(0,len(X_test)):
    x1 = d.predict([X_test3[i].reshape(-1,64,64,1),X_test2[i].reshape(-1,64,64,1)])
    x1 = turn1Channel(x1)
    plt.imsave(f'./gdrive/MyDrive/{Model_path}/{i}_predict.png',x1,cmap='gray')


    plt.imsave(f'./gdrive/MyDrive/{Model_path}/{i}_truth.png',y_test2[i].reshape(64,64),cmap='gray')'''
print(len(X_test))
X_test,y_test,X_test1 = Process_Data(X_test,y_test,X_test1,64)
X_test2,y_test2,X_test3 = Process_Data(X_test2,y_test2,X_test3,64)
print(X_test.shape)
for i in range(0,len(X_test)):
  x1 = d.predict([X_test[i].reshape(-1,64,64,1),X_test1[i].reshape(-1,64,64,1)])
  x1 = turn1Channel(x1)
  plt.imshow(X_test1[i].reshape(64,64),cmap='gray')
  plt.show()

  plt.imshow(x1.reshape(64,64),cmap='gray')
  plt.show()



  plt.imshow(y_test2[i].reshape(64,64),cmap='gray')
  plt.show()

X_test,y_test = module.Load_Data('full',['BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015','BRATS_HG0001','BRATS_HG0015','BRATS_LG0006','BRATS_LG0008'],'T1C')
X_test1,y_test1 = module.Load_Data('full',['BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015','BRATS_HG0001','BRATS_HG0015','BRATS_LG0006','BRATS_LG0008'],'FLAIR')
X_test2,y_test2 = module.Load_Data('full',['BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015','BRATS_HG0001','BRATS_HG0015','BRATS_LG0006','BRATS_LG0008'],'T2')
X_test3,y_test3 = module.Load_Data('full',['BRATS_HG0025','BRATS_HG0026','BRATS_HG0027','BRATS_LG0013','BRATS_LG0014','BRATS_LG0015','BRATS_HG0001','BRATS_HG0015','BRATS_LG0006','BRATS_LG0008'],'T1')

X_test[0] = X_test[0][:-4]
y_test[0] = y_test[0][:-4]

X_test1[0] = X_test1[0][:-4]
y_test1[0] = y_test1[0][:-4]

X_test2[0] = X_test2[0][:]
y_test2[0] = y_test2[0][:]

X_test3[0] = X_test3[0][:-4]
y_test3[0] = y_test3[0][:-4]

X_test[2] = X_test[2][:-1]
y_test[2] = y_test[2][:-1]

X_test1[2] = X_test1[2][:]
y_test1[2] = y_test1[2][:]

X_test2[2] = X_test2[2][:]
y_test2[2] = y_test2[2][:]

X_test3[2] = X_test3[2][:-1]
y_test3[2] = y_test3[2][:-1]


X_test[3] = X_test[3][:-1]
y_test[3] = y_test[3][:-1]

X_test1[3] = X_test1[3][:-1]
y_test1[3] = y_test1[3][:-1]

X_test2[3] = X_test2[3][:]
y_test2[3] = y_test2[3][:]

X_test3[3] = X_test3[3][:-1]
y_test3[3] = y_test3[3][:-1]


X_test[4] = X_test[4][:-2]
y_test[4] = y_test[4][:-2]

X_test1[4] = X_test1[4][:-2]
y_test1[4] = y_test1[4][:-2]

X_test2[4] = X_test2[4][:]
y_test2[4] = y_test2[4][:]

X_test3[4] = X_test3[4][:-2]
y_test3[4] = y_test3[4][:-2]

X_test[5] = X_test[5][2:-1]
y_test[5] = y_test[5][2:-1]

X_test1[5] = X_test1[5][2:-1]
y_test1[5] = y_test1[5][2:-1]

X_test2[5] = X_test2[5][:]
y_test2[5] = y_test2[5][:]

X_test3[5] = X_test3[5][2:-1]
y_test3[5] = y_test3[5][2:-1]
d = models.load_model(f'./gdrive/MyDrive/T1C/64.h5',custom_objects={"dice_coef_edema":dice_coef_edema,"jaccard_distance_edema":jaccard_distance_edema,"dice_coef_tumor":dice_coef_tumor,"jaccard_distance_tumor":jaccard_distance_tumor})

opt = optimizers.Adam(learning_rate=0.0001,decay=1e-6)

d.compile(loss = "categorical_crossentropy", optimizer = opt,metrics=[jaccard_distance_edema,dice_coef_edema,jaccard_distance_tumor,dice_coef_tumor])
  
first,truth,secend = Process_Data(X_test[i],y_test[i],X_test1[i],64)
third,truth2,fourth = Process_Data(X_test2[i],y_test2[i],X_test3[i],64)
truth = turn3Channel(truth)
_,je,de,jt,dt = d.evaluate(first,truth)